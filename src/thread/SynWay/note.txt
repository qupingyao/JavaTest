cas原理:
一种乐观锁，通过jni,借助cpu底层指令实现
以public final native boolean compareAndSwapInt(Object obj, long l, int i, int j);方法为例:
底层指令为cmpxchg
对于单核cpu，cpu自动保证该指令的原子性
对于多核cpu，为该指令添加lock前缀(lock cmpxchg)，借助总线锁定或缓存锁定来保证指令的原子性

cpu保证内存原子操作的三种方式:
	1):处理器自动保证基本操作的原子性
	        处理器保证从内存中读取或者写入一个字节是原子的，最新的处理器能保证对映射到同一个缓存行里的16/32/64位数据(不同处理器不同)的内存操作是原子的
	2):使用总线锁定保证原子性
	　　所谓总线锁就是处理器执行时锁住总线，独占使用内存，而其他处理器的总线请求会被堵塞
	3):使用缓存锁定保证原子性
	        每个处理器都有自己独占的一级缓存，处理器读取数据是以缓存行为最小单元读取的，哪怕指令只需要读取缓存行中一部分数据
	       所谓缓存锁定就是处理器锁住自己内部操作内存所对应的某一个缓存行(需要保证当前处理器内的该缓存行处于独占或已修改状态)，直接修改缓存行的数据，借助缓存一致性机制来保证内存操作的原子性，缓存一致性机制会阻止其他处理器对同一内存区域所对应的那一个缓存行数据的修改，缓存锁定相比总线锁定效率更高
	       有两种情况无法使用缓存锁定:
	      1):操作的内存数据不能被缓存，或操作的内存数据对应到处理器内部缓存的多个缓存行
	      2):部分处理器不支持缓存锁定
	      
threadlocal原理:
	1):ThreadLocal<T>类内部有一个静态类ThreadLocalMap
	2):每个Thread线程实例对象内部都有一个ThreadLocalMap类的实例变量
	3):ThreadLocalMap类内部有一个静态类Entry(实现了WeakReference<ThreadLocal<?>>)作为一个键值对，其中key是ThreadLocal<?>类的实例变量，这个key是一个弱引用，value为这个实例变量的值
	         相比key使用强引用，如果当前线程下ThreadLocal<T>实例变量指向了新的内存空间，如果旧空间的引用只有当前Thread线程实例对象内的ThreadLocalMap实例变量才持有，其实旧空间已经没有存在的必要了，弱引用相比强引用能借助gc定时清理这部分旧空间
	         因为键值对的value依赖于key，不可能设置为弱引用，虽然key设置为弱引用后gc回收了key的旧空间，但是value的旧空间如果需要回收的话gc就没办法了，由于有没有消息通知机制，只能在ThreadLocalMap触发某些操作时清理这部分空间
	4):ThreadLocalMap类实例对象内有一个Entry数组，即一个桶数组，这个数组内部实现是一个线性探测hash表(每个桶内只有一个键值对，没有链表和红黑树，如果发生hash冲突则直接放到桶数组下一个空桶内(从hash算法指定的位置起))，
	         一开始这个桶数组为空，只有当前线程下某个ThreadLocal<T>实例变量被初始化时桶数组才会被初始化(初始capacity=16，threshold=10)，负载因子loadFactor为2/3
	        每一个ThreadLocal<T>类实例变量的hashcode以<T>为分组，0为初始值，1640531527为增量(减少hash冲突)
	   threadlocal实现的核心就是对每个Thread线程实例对象内部的ThreadLocalMap类实例变量内的桶数组进行各种操作
	5):对于桶数组内的每一个键值对，有以下三种情况
		1):情况一-->键值对为空，即该桶为空
		2):情况二-->键值对不为空，key为空，这种情况属于系统gc清理了key，该键值对无效，需要释放value的内存空间
		3):情况三-->键值对不为空，key不为空，这种情况下该键值对有效
	以下为桶数组的执行逻辑:
	1):rehash机制:
		1.触发全局清理机制
		2.如果触发全局清理机制后桶数组内键值对(非空)的数量超过threshold - threshold / 4，触发resize机制
	2):局部清理机制expungeStaleEntry:
		1.以指定位置开始(指定位置键值对必须处于情况二才能使用局部清理机制)
			释放指定位置键值对value的引用，且设置指定位置键值对为空
		2.以指定位置的下一个位置为起点，直到碰到下一个空键值对为止，向后依次遍历每一个键值对
			1):如果当前键值对处于情况二，则释放当前位置键值对value的引用，且设置当前位置键值对为空
			2):如果当前键值对处于情况三，重新根据当前键值对的key计算桶数组下标，放到该下标所在位置起的第一个空桶内，如果有必要则设置原位置键值对为空
		3.返回步骤2遍历终点空键值对的桶下标
	3):全局清理机制:
		1.遍历桶数组的每个桶的键值对，对于每个处于情况二的键值对，以该键值对所在位置为参数触发局部清理机制	
	4):resize机制:
		该机制与hashtable扩容机制类似，只是使用了线性探测算法来防止hash冲突，resize后capacity和threshold都翻一倍
	5):移除键值对逻辑:
		1.根据移除ThreadLocal实例变量的hashcode计算出桶数组启始下标
		2.以启始下标所在位置为起点，直到碰到下一个空键值对为止，向后按顺序访问键值对
			1):如果当前键值对的key和待移除ThreadLocal实例变量的引用相同(两个引用指向相同的空间)，释放key的弱引用，
			     以当前位置为参数触发局部清理机制，方法结束
    6):根据key查询键值对逻辑:
    	1.根据移除ThreadLocal实例变量的hashcode计算出桶数组启始下标
    	2.以启始下标所在位置为起点，直到碰到下一个空键值对为止，向后按顺序访问键值对
    		1):如果当前键值对为空，返回null
    		2):如果当前键值对的key和待移除ThreadLocal实例变量的引用相同(两个引用指向相同的空间)，返回当前键值对
			3):如果当前键值对不为空，但是键值对key为空， 以当前位置为参数触发局部清理机制(此时由于可能存在桶压缩，下轮访问的桶下标依旧是本次访问的桶下标)
	7):局部顺序清理机制(int i(位置下标，局部清理机制从桶下标i+1开始),int n(初始扫描长度，整个局部顺序清理机制最小扫描log2(n)的桶数量)
		private boolean cleanSomeSlots(int i, int n) {
            boolean removed = false;
            Entry[] tab = table;
            int len = tab.length;
            do {
                i = nextIndex(i, len);   /**等价于 i = (i + 1 < len) ? i + 1 : 0;**/
                Entry e = tab[i];
                if (e != null && e.get() == null) { /**如果当前键值对处于情况二**/
                    n = len; /**重置扫描长度**/
                    removed = true;
                    i = expungeStaleEntry(i);/**调用局部清理机制**/
                }
            } while ( (n >>>= 1) != 0);/**无符号右移1位**/
            return removed;
        }
     8):根据key-value设置键值对逻辑:
     	1.根据待设置键值对的key的hashcode计算出桶数组启始下标
    	2.以启始下标所在位置为起点，直到碰到下一个空键值对为止，向后按顺序访问键值对
    		1):如果当前键值对处于情况三且key与待设置键值对的key相同(两个ThreadLocal类型的引用指向相同的空间)，则覆盖当前键值对value的值，方法结束
    		2):如果当前键值对处于情况二，以待设置键值对的key，value和当前键值对所处位置为下标触发向前向后清理机制，方法结束
			3):如果当前键值对处于情况一，在当前键值对位置放置待设置键值对，之后以当前键值对所处位置为下标，当前桶数组内非空键值对数量为初始扫描长度触发局部顺序清理机制，如果局部顺序清理机制返回false且当前桶内非空键值对数量大于等于threshold，触发rehash机制
     9):向前向后清理机制(该机制只用于根据key-value设置值)replaceStaleEntry:
     	该方法接收三个参数：待设置键值对key，待设置键值对value，指定位置下标(该下标所在键值对必须处于情况二)
     	1.以指定位置下标所在位置为起点，直到碰到下一个空键值对为止，向前按顺序访问键值对，如果遇到第一个处于情况二的键值对则终止，记录该该键值对下标slotToExpunge，否则记slotToExpunge=指定位置下标
		2.以指定位置下标所在位置为起点，直到碰到下一个空键值对为止，向后按顺序访问键值对
			1):如果当前键值对处于情况三且key与待设置键值对的key相同(两个ThreadLocal类型的引用指向相同的空间)
				1.设置当前位置键值对的value为待设置键值对的value值
				2.把当前位置的键值对与指定位置的键值对(无效键值对)交换
				3.如果之前的向前顺序访问键值对没有遇到情况二的键值对(即slotToExpunge=指定位置下标)，设置清除起点为当前位置下标(经过上一步的交换后当前位置的键值对处于情况二)，否则设置清除起点下标为slotToExpunge
				4.以清除起点位置下标为参数触发局部清理机制
				5.以上一步返回的局部清理机制返回值为起点，桶数组大小为初始扫描长度，触发局部顺序清理机制，方法结束
			2):如果当前键值对处于情况三，如果之前的向前向后顺序访问键值对还没有遇到情况二的键值对(即slotToExpunge=指定位置下标)，设置slotToExpunge=当前位置下标，循环继续
			3):如果当前键值对为空
				1.释放指定位置键值对value的引用，之后将待设置键值对放在指定位置上
				2.如果之前的向前向后顺序访问键值对遇到过情况二的键值对(即slotToExpunge!=指定位置下标)，设置清除起点下标为slotToExpunge，以清除起点位置下标为参数触发局部清理机制
				3.如果上一步触发了局部清理机制，则以上一步返回的局部清理机制返回值为起点，桶数组大小为初始扫描长度，触发局部顺序清理机制，方法结束
				
synchronized原理:
java对象头markword
		锁标志位	是否是偏向锁
无锁状态        01		0
偏向锁	01		1
轻量级锁	00		0
重量级锁	10		0
GC标记	11		0

首先简单说下先偏向锁、轻量级锁、重量级锁三者各自的应用场景：

偏向锁：适用于同一时刻只有一个线程在请求进入或已进入临界区的情况，即不存在竞争的情况；
轻量级锁：适用于同一时刻多个线程在请求进入或已进入临界区的情况，但是竞争不是很激烈的情况；
重量级锁：适用于同一时刻多个线程在请求进入或已进入临界区的情况，但是竞争很激烈的情况；

偏向锁原理:本质上是无锁竞争下可重入锁的简单实现
	当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，
	以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，
	如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，
	则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
	
	偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
	偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），
	它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，
	如果线程不处于活动状态，则将对象头设置成无锁状态，
	如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，
	栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

上面的意思是，先暂停持有偏向锁的线程，尝试直接切换。如果不成功，就继续运行，并且标记对象不适合偏向锁，锁膨胀（锁升级）。
详见，上面有张图中的“偏向锁抢占模式”：
其中提到了mark word中的lock record指向堆栈最近的一个线程的lock record，其实就是按照先来后到模式进行了轻量级的加锁。

三种锁膨胀逻辑：
	1:当前线程访问同步块，查看同步锁对象头markword的标志位
		1):markword标志位为01，即处于无锁状态或者偏向锁状态
			1):查看markword判断是否是偏向锁
				1):不是偏向锁，当前同步锁对象处于无锁状态
				2):是偏向锁
				
		1):锁对象标志位为01
		1):锁对象标志位为01

				







	      

http://www.cnblogs.com/chen77716/archive/2011/07/28/2130795.html
http://blog.csdn.net/vincent1007/article/details/53999073
http://blog.csdn.net/lemon89/article/details/50734562
https://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-clh-and-spin-lock.html
https://www.cnblogs.com/daxin/p/3365324.html
https://www.cnblogs.com/wade-luffy/p/5969418.html
