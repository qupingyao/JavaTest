tcp报文格式:
	tcp报文 = tcp报文头 + 数据部分

	|------------------------------------------------------------------|
	|			    源端口号(16位)            |         目的端口号(16位) 		   |
	|------------------------------------------------------------------|
	|								        顺序号(32位)					   |
	|------------------------------------------------------------------|
	|								        确认号(32位)					   |
	|------------------------------------------------------------------|
	| 头部长(4位)|  保留位(6位) |  控制位(6位)  |          窗口大小(16位)		   |
	|------------------------------------------------------------------|
	|			     校验和(16位)             |		         紧急指针(16位)   	   |
	|------------------------------------------------------------------|
	|				                                                        可选项											   |
	|------------------------------------------------------------------|
	|															       |
	|																   |
	|							                  数据部分						       |
	|																   |
	|												|------------------|				   |
	|												|				   
	|-----------------------------------------------|
	
	1):源端口号和目的端口号:
		每个计算机共65536个端口，折合成二进制为16位
		tcp报文头中的源端口号和目的端口号加上ip数据报中的源ip与目的ip唯一确定一条tcp连接

	2):顺序号:
		tcp报文的数据部分每个字节都有一个序号，顺序号指数据部分第一个字节的序号，序号确保了tcp传输的有序性
		eg:一个tcp报文的序号为300，此报文数据部分共有100个字节，则下一个tcp报文的序号为400
	3):确认号
		只有当ACK控制位为1时才有效，表示下一个期望接收到的tcp报文头中的顺序号，也表明该顺序号之前的所有数据已经正确无误的收到
		除了主动发起tcp连接的第一个tcp报文ACK控制位为0，其后发送的tcp报文ACK控制位都为1
	4):头部长
		tcp报文头的长度，该字段以4个字节为基本单位，因此tcp报文头最大长度是60个字节
	5):控制位
	           共6位，每位一个独立控制位，按顺序依次为:URG，ACK，PSH，RST，SYN，FIN,设置为1时有效
		URG:紧急位，为1时，tcp报文头的紧急指针有效
		ACK:确认位，为1时，tcp报文头的确认号有效
		PSH:push位，为1时有效，指示接收方在接收到该tcp报文后，应尽快将这个报文交给应用程序，而不是在缓冲区排队
		RST:复位标志，为1时有效，一般在出现错误或异常连接时使用，复位tcp连接
		SYN:同步位，仅在tcp三次握手时为1，有效，当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，在发回的报文段中使SYN=1和ACK=1
		FIN:结束位，为1时有效，表示发送方已经没有数据发送了

6. 窗口

占2字节，表示报文段发送方期望接收的字节数，可接收的序号范围是从接收方的确认号开始到确认号加上窗口大小之间的数据。

7. 校验和

校验和包含了伪首部、TCP首部和数据，校验和是TCP强制要求的，由发送方计算，接收方验证。

8. 紧急指针

URG标志为1时，紧急指针有效，表示数据需要优先处理。紧急指针指出在TCP段中的紧急数据的最后一个字节的序号，使接收方可以知道紧急数据共有多长。

9. 选项

最常用的选项是最大段大小（Maximum Segment Size，MSS），向对方通知本机可以接收的最大TCP段长度。MSS选项只在建立连接的请求中发送。
	
	
https://blog.csdn.net/bytxl/article/details/46467771	



tcp三次握手:
	            方向                           控制位               顺序号        确认号  
	1)	客户端->服务端     000010   1000         无效 
	2)  服务端->客户端     010010   2000   1001  
	3)  客户端->服务端     010000   1001   2001   
	
	客户端                                                                                                 服务端
	
	----								 ----
	 |									  |
	 |									  |
	 |									  |
	 |									  |
	 | closed                             |
	 |									  |
	 |									  |
	----								  |  listen
	 |\  								  |
	 | \								  |
	 |  \								  |
	 |   \	   控制位-->000010                |
	 |    \--------------------------\	  |
	 |    	   顺序号-->1000        确认号-->无效     \	  |
	 |							       \  |
     |								  	\ |
	 |                                   \|
	 | syn_sent                          ----  把客户端请求放入半连接队列
	 | 									 /|
	 |									/ |
	 |								   /  |
	 |		  控制位-->010010			  /   |
	 |    /--------------------------/    |
	 |   / 	  顺序号-->2000        确认号-->1001	  |
  	 |  /                                 |
  	 | /                                  |
  	 |/                                   |                                   
	----                                  | syn_rcvd
	 |\                                   |
	 | \                                  |
	 |  \                                 |
	 |   \	  控制位-->010000           	  |
	 |    \--------------------------\    |
	 |    	  顺序号-->1001       确认号-->2001 \   |
     |								   \  |
	 |				  					\ |
	 |				  		             \|
	 |	established						 ----  把客户端请求从半连接队列放入全连接队列
	 |                                    |
	 |                                    |
	 |                                    |
	 |                                    | established
	 |                                    |
	 |                                    |
	 |                                    |
	----					             ----
	
	当Client端收到Server的SYN+ACK应答后，其状态变为ESTABLISHED，并发送ACK包给Server；
 
            如果此时ACK在网络中丢失，那么Server端该TCP连接的状态为SYN_RECV，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。
           
             Server重发SYN+ACK包的次数，可以通过设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5。
             
             如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。
             但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包响应，方能感知到Server的错误。
	
	
tcp四次挥手：
	            方向                           控制位               顺序号                  确认号  
	1)	客户端->服务端     010001   1000(u)   2000(v-1)
	2)  服务端->客户端     010000   2001(v)   1001(u+1)  
	3)  服务端->客户端     010001   3000      1001  
	3)  客户端->服务端     010000   1001      3001 
	
	客户端                                                                                                 服务端
	
	----								 ----
	 |									  |
	 |									  |
	 |									  |
	 |									  |
	 | established                        |
	 |									  |
	 |									  |
	----								  |  established
	 |\  								  |
	 | \								  |
	 |  \								  |
	 |   \	   控制位-->010001                |
	 |    \--------------------------\	  |
	 |    	   顺序号-->1000         确认号->2000 \	  |
	 |							       \  |
     |								  	\ |
	 |                                   \|
	 | fin_wait_1                        ----  
	 | 									 /|
	 |									/ |
	 |								   /  |
	 |		  控制位-->010000			  /   |
	 |    /--------------------------/    |  close_wait
	 |   / 	  顺序号-->2001          确认号-->1001	  |
  	 |  /                                 |
  	 | /                                  |
  	 |/                                   |                                   
	----                                 ---- 
	 |	                                  |             
	 |                                    |
	 |                                    |
	 |                                   /|
	 |  fin_wait_2                      / |
	 |                                 /  |
	 |   	  控制位-->010001   	      /   |
	 |    /--------------------------/    |
	 |   /   顺序号-->3000         确认号-->1001    |
     |	/							      |
	 | /			  					  |
	 |/				  		              |
  ------								  |  last_ack
  |	 |\                                   |
  |	 | \                                  |
  |	 |  \                                 |
  |2 |   \   控制位-->010000                | 
  |M |    \--------------------------\    |  
  |S |       顺序号-->1001   确认号-->3001\   |
  |L |                                 \  |
  |  |	time_wait				        \ |
  |  |  							     \|
  |  | 								 	 ----
  |  |     						          |
  ------                 				  |
  	 |    	                              |
  	 |    	   	                          |  closed
  	 |	closed						      |
     |								  	  |
  	 |                                    |
    ----								 ----

	
https://segmentfault.com/a/1190000008224853
https://blog.csdn.net/hguisu/article/details/38700899
2.2、SYN Flood 防护措施

2.2.1． 无效连接监视释放 
这种方法不停的监视系统中半开连接和不活动连接，当达到一定阈值时拆除这些连接，释放系统资源。这种绝对公平的方法往往也会将正常的连接的请求也会被释放掉，”伤敌一千，自损八百“ 
2.2.2． 延缓TCB分配方法 
SYN Flood关键是利用了，SYN数据报文一到，系统立即分配TCB资源，从而占用了系统资源，因此有俩种技术来解决这一问题 
Syn Cache技术 
这种技术在收到SYN时不急着去分配TCB，而是先回应一个ACK报文，并在一个专用的HASH表中（Cache）中保存这种半开连接，直到收到正确的ACK报文再去分配TCB 
Syn Cookie技术 
Syn Cookie技术则完全不使用任何存储资源，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源 
	
	