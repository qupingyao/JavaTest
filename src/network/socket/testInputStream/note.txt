socket输入输出流一些细节:
	1):无论客户端服务端，socket实例创建完成后，操作系统就会为这个实例分配读缓冲区和写缓冲区，这个读缓冲区和写缓冲区的大小可以在java socket编程中设置，但是由于受限于操作系统底层的具体实现，设置值并不靠谱
 	2):向socket的输出流写数据只是把数据写到当前实例的写缓冲区，从socket的输入流读只是从当前实例的读缓冲区取数据
	         实际的客户端服务端双方缓冲区数据的交换由双方操作系统的TCP协议栈完成，java socket在应用层无法干涉
	3):当写缓冲区满时，对应socket实例的输出流会堵塞
	4):当读缓冲区为空时，对应socket实例的输入流会堵塞
	5):socket实例的输入流调用read()时要么堵塞，要么返回一个字节对应的int值，要么返回-1示意读到了末尾，这种读到末尾的情况发生在另一端的socket实例关闭或者另一端的socket实例关闭了输出流的情况
	6):socket实例关闭后另一端的socket实例的输出流在写数据时就会异常，但是输入流依旧能继续工作
	7):socket编程使用ObjectOutputStream时，由于ObjectOutputStream自身的机制，在调用ObjectOutputStream(OutputStream)构造器时，会在依赖的输出流内写入认证数据
	   socket编程使用ObjectInputStream时，由于ObjectInputStream自身的机制，在调用ObjectInputStream(InputStream)构造器时，会从依赖的输入流内读入认证数据，如果读不到则堵塞
	         因为ObjectInputStream(InputStream)构造器的堵塞机制，在socket编程时服务端和客户单不能同时先调用ObjectInputStream(InputStream)构造器，后调用ObjectOutputStream(OutputStream)构造器，否则会因为同时堵塞而死锁

