hashtable原理:
	内置一个桶数组，同一桶内的所有键值对(hash冲突)形成链表
	capacity:桶数组的大小，默认为11，最大为Integer.MAX_VALUE
	threshold:当整个hashtable内键值对个数达到threshold时触发扩容机制，最大为Integer.MAX_VALUE - 7，
		                  一般记负载因子loadFactor = threshold/capacity 保持在一个恒定的值，默认为0.75(hashtable时间与空间的一个平衡)，可以大于1
	static final int hash(Object key) {
        return (key.hashCode() & 0x7FFFFFFF);/** & 0x7FFFFFFF(Integer.MAX_VALUE)是为了防止结果是负数**/
    }
	1):添加元素逻辑:
	    1:将添加的key调用hash()方法后的值(下面统称hashkey)用求余的方法确定键值对放在哪个目标桶里
	          1):如果目标桶内为空，直接放
	          2):如果目标桶内非空，用key的equals()方法判断目标桶的链表内是否有相同的key
	          		1):如果有相同的key就直接覆盖value
	          		2):如果没有相同的key
	          			1):如果当前hashtable内键值对个数已经达到threshold(还没放新键值对时)，触发rehash机制，重新计算新键值对所在目标桶下标
	          			2):将新键值对放到目标桶内所有键值对所形成的链表的头部
	2):删除元素逻辑:
	    1:将删除的key调用hash()方法后的值(下面统称hashkey)用求余的方法确定待删除键值对放在哪个目标桶里
			  1):如果目标桶不为空，用key的equals()方法判断出目标桶内所有键值对所形成链表内是否存在此key，存在则删除该键值对
	3):rehash机制(类似hashmap的扩容机制，只是在部分极端情况下桶数组会变小):
		1:计算rehash后桶数组的capacity和threshold
			  1):如果oldCapacity=逻辑最大值Integer.MAX_VALUE - 8，rehash结束
			  1):计算新的桶数组大小capacity = oldCapacity*2+1;
			  2):如果capacity为负或者超过逻辑最大值Integer.MAX_VALUE - 8 ，调整为逻辑最大值Integer.MAX_VALUE - 8(有可能capacity还小于oldCapacity)
			  3):按比例调整threshold(如果超过最大值就设置为最大值)
		2:按照新计算的capacity值新建新的桶数组，对旧桶数组内每一个桶内的所有键值对重新计算其在新桶数组内的桶数组下标，放到对应桶内所有键值对所形成的链表的头部
	6):注意事项:
			1):hashtable的添加方法必须添加新键值对(非覆盖)才会触发modCount改变，删除方法也必须删除键值对才触发，单纯的replace()方法也不会触发
         
	
		